---
layout: post
title:  "Handler"
date:   2019-3-13 01:00:00
categories: Android
tags: Source code
image:
  feature: wjoel_180413_1777_android_001.0.jpg
  topPosition: -100px
bgContrast: dark
bgGradientOpacity: darker
syntaxHighlighter: no
---


## 示例代码

使用Handle和Message在线程间通信

```Java
package com.example.yanghan.myapplication;

import android.os.Handler;
import android.os.Message;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity {

    private TextView textView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        textView=(TextView) findViewById(R.id.textView);
        SampleTask sampleTask=new SampleTask( myHandler);
        Thread workThread=new Thread(sampleTask);
        workThread.start();
    }
    void appendText(String msg) {
        textView.setText( msg);
    }

    public Handler myHandler = new Handler() {

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case 1:
                    String result = msg.getData().getString("message");
                    appendText(result);//你想要做的事情

                    break;
            }

        }

    };



}
class SampleTask  implements Runnable {
    String TAG = SampleTask.class.getSimpleName();
    Handler myHandler;

    SampleTask(Handler myHandler) {

        this.myHandler = myHandler;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(5000);
            Message msg = prepareMessage("task completed!");
            myHandler.sendMessage(msg);
        }  catch (InterruptedException e) {
            Log.d(TAG, "interrupted!");
        }
    }
    private Message prepareMessage(String str)
    {
        Message result = myHandler.obtainMessage();
        Bundle data = new Bundle();
        data.putString("message", str);
        result.setData(data);
        result.what=1;
        return  result;
    }

}
```

## 原理

![img](http://static.oschina.net/uploads/space/2014/0622/194707_TItG_1391648.png)

## 源码解析



### Message

 android.os.Message的主要功能是进行消息的封装，同时可以指定消息的操作形式，Message类定义的变量和常用方法如下：

（1）public int what：变量，用于定义此Message属于何种操作

（2）public Object obj：变量，用于定义此Message传递的信息数据，通过它传递信息

（3）public int arg1：变量，传递一些整型数据时使用

（4）public int arg2：变量，传递一些整型数据时使用

（5）public Handler getTarget()：普通方法，取得操作此消息的Handler对象

 在整个消息处理机制中，**message**又叫task，**封装了**任务携带的**信息**和处理该任务的**handler**。message的用法比较简单，但是有这么几点需要注意：

（1）尽管Message有public的默认构造方法，但是你应该通过Message.obtain()来从消息池中获得空消息对象，以节省资源。

（2）如果你的message只需要携带简单的**int**信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存

（3）擅用message.**what**来**标识信息**，以便用不同方式处理message。

（4）使用setData()存放**Bundle**对象。

 

### Looper

```java
public class Looper {
    // 每个线程中的Looper对象其实是一个ThreadLocal，即线程本地存储(TLS)对象
    private static final ThreadLocal sThreadLocal = new ThreadLocal();
    // Looper内的消息队列
    final MessageQueue mQueue;
    // 当前线程
    Thread mThread;
    //其他属性
    // 每个Looper对象中有它的消息队列，和它所属的线程
    
    //循环获取MQ中的消息，并发送给相应Handler对象
    private Looper() {
        mQueue = new MessageQueue();
        mRun = true;
        mThread = Thread.currentThread();
        
        //循环操作
    }
    
    
    // 我们调用该方法会在调用线程的TLS中创建Looper对象
    public static final void prepare() {
        if (sThreadLocal.get() != null) {
            
            
            // 试图在有Looper的线程中再次创建Looper将抛出异常
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper());
    }
    // 其他方法
}
```



```java
public class LooperThread extends Thread {
    @Override
    public void run() {
        // 将当前线程初始化为Looper线程
        Looper.prepare();
         
        // ...其他处理，如实例化handler
         
        // 开始循环处理消息队列
        Looper.loop();
    }
}

```

**Looper.prepare()：创建Loop而对象。**

**Looper.loop()：循环获取MQ中的消息，并发送给相应Handler对象。**



```java
 public static final void loop() {
        Looper me = myLooper();  //得到当前线程Looper
        MessageQueue queue = me.mQueue;  //得到当前looper的MQ
         
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();
     
        // 开始循环
        while (true) {
            Message msg = queue.next(); // 取出message
            if (msg != null) {
                if (msg.target == null) {
                    
                    // message没有target为结束信号，退出循环
                    return;
                }
                
                // 日志
                if (me.mLogging!= null) me.mLogging.println(
                        ">>>>> Dispatching to " + msg.target + " "
                        + msg.callback + ": " + msg.what
                        );
                // 非常重要！将真正的处理工作交给message的target，即后面要讲的handler
                
                msg.target.dispatchMessage(msg);
                // 日志
                
                if (me.mLogging!= null) me.mLogging.println(
                        "<<<<< Finished to    " + msg.target + " "
                        + msg.callback);
                 
                final long newIdent = Binder.clearCallingIdentity();
                if (ident != newIdent) {
                    Log.wtf("Looper", "Thread identity changed from 0x"
                            + Long.toHexString(ident) + " to 0x"
                            + Long.toHexString(newIdent) + " while dispatching to "
                            + msg.target.getClass().getName() + " "
                            + msg.callback + " what=" + msg.what);
                }
                // 回收message资源
                msg.recycle();
            }
        }
    }

```



### Handler

```java
public class Handler {
    final MessageQueue mQueue;  // 关联的MQ
    final Looper mLooper;  // 关联的looper
    final Callback mCallback; 
    // 其他属性
    
    public Handler() {
        if (FIND_POTENTIAL_LEAKS) {
            final Class<? extends Handler> klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
                    (klass.getModifiers() & Modifier.STATIC) == 0) {
                Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName());
            }
        }
        
        // 默认将关联当前线程的looper
        mLooper = Looper.myLooper();
        
        // looper不能为空，即该默认的构造方法只能在looper线程中使用
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }
        
        // 重要！！！直接把关联looper的MQ作为自己的MQ，因此它的消息将发送到关联looper的MQ上
        mQueue = mLooper.mQueue;
        mCallback = null;
    }
     
    // 其他方法
}
```



有了handler之后，我们就可以使用

 **post(Runnable)**

 **postAtTime(Runnable, long)**

 **postDelayed(Runnable, long)**

 **sendEmptyMessage(int)**

**sendMessage(Message)**

**sendMessageAtTime(Message, long)**

**sendMessageDelayed(Message, long)**



1.**message.target为该handler对象**，这确保了looper执行到该message时能找到处理它的handler，即loop()方法中的关键代码

```
msg.target.dispatchMessage(msg);
```

2.post发出的message，**其callback为Runnable对象**



**消息的处理是通过核心方法dispatchMessage(Message msg)与钩子方法handleMessage(Message msg)完成的**

```java
public void dispatchMessage(Message msg) {  
        if (msg.callback != null) {  
            //post
            handleCallback(msg);  
        } else {  
            if (mCallback != null) {  
                if (mCallback.handleMessage(msg)) {  
                    return;  
                }  
            }  
            //sendMessage
            handleMessage(msg);  
        }  
    } 
```

